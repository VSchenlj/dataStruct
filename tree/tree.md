# 树
## 1 二叉树
### 1.1 定义
    二叉树（Binary Tree):n（n>=0)个结点的有限集合，该集合或为空集（称为空二叉树），或由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树
    的二叉树组成。
### 1.1.1 二叉树特点
* 每个结点最多有两棵子树，不存在度大于2的结点；
* 左子树和右子树有次序，不能颠倒；
* 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。
### 1.1.2 特殊二叉树
**i、斜二叉树**   
  左斜树：所有结点都只有左子树的二叉树；  
  右斜树：所有结点都只有右子树的二叉树。  
  
**ii、满二叉树**  
    所有分支结点都存在左右子树，且所有叶子结点都在同一层的二叉树。  
  特点：
* 叶子结点只能出现在最下一层；
* 非叶子结点的度为2；
* 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。  

**iii、完全二叉树**  
    对一棵具有n个结点的二叉树按层序编号，如果编号为i（1<=i<=n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。  
  特点：
* 叶子结点只能出现在最下两层；
* 最下层的叶子一定集中在左部连续位置；
* 倒数二层，如果存在叶子结点，一定都在右部连续位置；
* 如果结点度为1，则该节点只有左孩子；
* 同样结点的二叉树，完全二叉树的深度最小。  

### 1.2 性质
* 性质1：在二叉树的第i层至多有2^(i-1)个结点（i>=1）；
* 性质2：深度为k的二叉树至多有(2^k)-1个结点（k>=1）；
* 性质3：具有n个结点的完全二叉树的深度为\[logn\]+1；
* 性质4：若对于一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i（1<=i<=n）有：  
    a、若i=1，则结点i是二叉树的根，无双亲；若i>!，则其双亲结点为\[i/2\]；  
    b、若2i>n，则结点i无左孩子，否则其左孩子位置为2i；  
    c、若2i+1>n，则结点i无右孩子，否则其右孩子位置为2i+1。  
### 1.3 二叉树结构（见代码）  

### 1.4 二叉树遍历  
### 1.4.1 原理  
    二叉树的遍历（traversing binary tree）：指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点有且仅被访问一次。  
### 1.4.2 方法
**i、前序遍历**  
  规则是若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树，如下图所示，遍历顺序为ABDGHCEIF。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png)  
**ii、中序遍历**
  规则是若二叉树为空，则空操作返回，否则从根节点开始，中序遍历根节点的左子树，然后是访问根节点，再中序遍历根节点的右子树。如下图所示，遍历顺序为GDHBAEICF。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png)  
**iii、后序遍历**
  规则是若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根节点。如下图所示，遍历顺序为GHDBIEFCA。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png)  
**iv、层序遍历**
  规则是若二叉树为空，则空操作返回，否则从树的第一层，也就是从根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。如下图所示，遍历顺序为ABCDEFGHI。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.png)  
### 1.4.3 性质
* 已知二叉树的前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树；
* 已知二叉树的中序遍历序列和后序遍历序列，可以唯一确定一棵二叉树。  

### 1.5 二叉树的建立（见代码）  

### 1.6 线索二叉树  
### 1.6.1 定义  
    将指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)。  
### 1.6.2 结构（见代码）  

### 1.7 树、森林与二叉树转换  
### 1.7.1 树转二叉树  
1）加线。在所有兄弟结点间加一条连线；  
2）去线。对树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点间的连线；  
3）层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。（注：第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子）。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png)  
### 1.7.2 森林转二叉树    
1）把每个树转为二叉树；  
2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png)  
### 1.7.3 二叉树转树  
1）加线。将每个结点的左孩子的n个右孩子结点都作为此结点的孩子；  
2）去线。删除原二叉树中所有结点与其右孩子的连线；  
3）层次调整。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A0%91.png)  
### 1.7.4 二叉树转换为森林  
    判断条件：若根节点没有右孩子，则二叉树转换为一棵树，否则，转换为森林。  
1）从根结点开始，若右孩子存在，则把右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除，依此类推，直到所有右孩子连线都删除为止，得到分离的二叉树；  
2）再将分离后的二叉树转换为树即可。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A3%AE%E6%9E%97.png)  