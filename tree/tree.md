# 树
## 1 二叉树
### 1.1 定义
    二叉树（Binary Tree):n（n>=0)个结点的有限集合，该集合或为空集（称为空二叉树），或由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树
    的二叉树组成。
### 1.1.1 二叉树特点
* 每个结点最多有两棵子树，不存在度大于2的结点；
* 左子树和右子树有次序，不能颠倒；
* 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。
### 1.1.2 特殊二叉树
**i、斜二叉树**   
  左斜树：所有结点都只有左子树的二叉树；  
  右斜树：所有结点都只有右子树的二叉树。  
  
**ii、满二叉树**  
    所有分支结点都存在左右子树，且所有叶子结点都在同一层的二叉树。  
  特点：
* 叶子结点只能出现在最下一层；
* 非叶子结点的度为2；
* 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。  

**iii、完全二叉树**  
    对一棵具有n个结点的二叉树按层序编号，如果编号为i（1<=i<=n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。  
  特点：
* 叶子结点只能出现在最下两层；
* 最下层的叶子一定集中在左部连续位置；
* 倒数二层，如果存在叶子结点，一定都在右部连续位置；
* 如果结点度为1，则该节点只有左孩子；
* 同样结点的二叉树，完全二叉树的深度最小。  

### 1.2 性质
* 性质1：在二叉树的第i层至多有2^(i-1)个结点（i>=1）；
* 性质2：深度为k的二叉树至多有(2^k)-1个结点（k>=1）；
* 性质3：具有n个结点的完全二叉树的深度为\[logn\]+1；
* 性质4：若对于一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i（1<=i<=n）有：  
    a、若i=1，则结点i是二叉树的根，无双亲；若i>!，则其双亲结点为\[i/2\]；  
    b、若2i>n，则结点i无左孩子，否则其左孩子位置为2i；  
    c、若2i+1>n，则结点i无右孩子，否则其右孩子位置为2i+1。  
### 1.3 二叉树结构（见代码）  

### 1.4 二叉树遍历  
### 1.4.1 原理  
    二叉树的遍历（traversing binary tree）：指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点有且仅被访问一次。  
### 1.4.2 方法
**i、前序遍历**  
  规则是若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树，如下图所示，遍历顺序为ABDGHCEIF。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png)  
**ii、中序遍历**
  规则是若二叉树为空，则空操作返回，否则从根节点开始，中序遍历根节点的左子树，然后是访问根节点，再中序遍历根节点的右子树。如下图所示，遍历顺序为GDHBAEICF。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png)  
**iii、后序遍历**
  规则是若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根节点。如下图所示，遍历顺序为GHDBIEFCA。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png)  
**iv、层序遍历**
  规则是若二叉树为空，则空操作返回，否则从树的第一层，也就是从根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。如下图所示，遍历顺序为ABCDEFGHI。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.png)  
### 1.4.3 性质
* 已知二叉树的前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树；
* 已知二叉树的中序遍历序列和后序遍历序列，可以唯一确定一棵二叉树。  

### 1.5 二叉树的建立（见代码）  

### 1.6 线索二叉树  
### 1.6.1 定义  
    将指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)。  
### 1.6.2 结构（见代码）  

### 1.7 树、森林与二叉树转换  
### 1.7.1 树转二叉树  
1）加线。在所有兄弟结点间加一条连线；  
2）去线。对树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点间的连线；  
3）层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。（注：第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子）。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png)  
### 1.7.2 森林转二叉树    
1）把每个树转为二叉树；  
2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png)  
### 1.7.3 二叉树转树  
1）加线。将每个结点的左孩子的n个右孩子结点都作为此结点的孩子；  
2）去线。删除原二叉树中所有结点与其右孩子的连线；  
3）层次调整。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A0%91.png)  
### 1.7.4 二叉树转换为森林  
    判断条件：若根节点没有右孩子，则二叉树转换为一棵树，否则，转换为森林。  
1）从根结点开始，若右孩子存在，则把右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除，依此类推，直到所有右孩子连线都删除为止，得到分离的二叉树；  
2）再将分离后的二叉树转换为树即可。  
  ![avatar](https://github.com/VSchenlj/dataStruct/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A3%AE%E6%9E%97.png)  

## 2 赫夫曼树  
### 2.1 基本概念  
* 路径长度：从树中的一个结点到一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。树的路径长度为树根到每一个结点路径长度之和。
* 带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为所有叶子结点带权路径长度之和。
### 2.2 定义  
    赫夫曼树：带权路径长度WPL最小的二叉树。  
### 2.3 构建过程  
1）根据给定的n个权值（w1,w2,...,wn）构成的n棵二叉树的集合F={T1,T2,...,Tn}，其中每棵二叉树T1中只有一个带权为w1根结点，左右子树均为空；
2）在F中选取两棵根结点的权值最小的树作为左右子树构造成一棵新的二叉树，且新的二叉树的权值为左右子树上根结点的权值之和；
3）在F中删除这两棵树，同时将新的二叉树加入到F中；
4）重复2、3步骤，直到F只含一棵树为止，即得到了赫夫曼树。  
### 2.4 赫夫曼编码
    一般地，设需要编码的字符集为{d1,d2,...,dn}，各个字符在电文中出现的次数或频率集合为{w1,w2,...,wn}，以d1,d2,...,dn作为叶子结点，以w1,w2,...,wn作为相应
    叶子结点的权值来构造一棵二叉树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，即
    赫夫曼编码。